# Multiplicacion *
2*3
3*1.4
pi*3
pi
# Division       /
4 / 3
2/7
-1/5
A <- matrix(c(1,2,3,4),nrow=2,ncol=2)
B <- matrix(c(1,0,0,1),nrow=2,ncol=2)
A*B
A%*%B
# Menor que     <
"a" < "b"
if(true){
3+4
}
if(TRUE){
3+4
}
if(TRUE){
3+4
}
if(TRUE){
3+4
}
if(FALSE){
3+4
}
if(3>4){
3+4
}
if(x>4){
x-4
}
x <- 3
if(x>4){
x-4
}
x <- 6
if(x>4){
x-4
}
x <- 3
y <- 4
if(x*y<12){
print0("El producto de x y y es mayor que 0.")
}
x <- 3
y <- 3
if(x*y<12){
print0("El producto de x y y es mayor que 0.")
}
if(x*y<12){
print("El producto de x y y es mayor que 0.")
}
x <- 23
if(x%%2==0){
"Es par"
}
x <- 24
if(x%%2==0){
"Es par"
}
if(x%%2==0) "Es par"
if(x%%2==0){
"Es par"
}else{
"Es impar"
}
x <- 25
if(x%%2==0){
"Es par"
}else{
"Es impar"
}
if(x%%3==0){
"Es multiplo de 3. Sobran 0."
}else if(x%%3==1){
"No es multiplo de 3. Sobra 1."
}else{
"No es multiplo de 3. Sobran 2."
}
x<- 8
x <- 8
if(x%%3==0){
"Es multiplo de 3. Sobran 0."
}else if(x%%3==1){
"No es multiplo de 3. Sobra 1."
}else{
"No es multiplo de 3. Sobran 2."
}
x <- 15
if(x%%3==0){
"Es multiplo de 3. Sobran 0."
}else if(x%%3==1){
"No es multiplo de 3. Sobra 1."
}else{
"No es multiplo de 3. Sobran 2."
}
x <- 15
if(x%%3==0){
"Es multiplo de 3. Sobran 0."
}else if(x%%3==1){
"No es multiplo de 3. Sobra 1."
"Hola."
}else{
"No es multiplo de 3. Sobran 2."
}
x <- 40
ifelse(x>25,"Es mayor que 25","No es mayor que 25")
x <- 23
ifelse(x>25,"Es mayor que 25","No es mayor que 25")
ifelse(x%%3==0,"Es multiplo de 3",ifelse(x%%3==1,"Sobra 1","Sobran 2"))
ifelse(x%%3==0,"Es multiplo de 3",ifelse(x%%3==1,"Sobra 1","Sobran 2"))
x <- 21
3
ifelse(x%%3==0,"Es multiplo de 3",ifelse(x%%3==1,"Sobra 1","Sobran 2"))
x <- 22
ifelse(x%%3==0,"Es multiplo de 3",ifelse(x%%3==1,"Sobra 1","Sobran 2"))
x <- 1:10
y <- 10:1
x>y
x
y
zona <- "B"
switch(zona,A=10,B=13,C=16,D=23,E=30)
?switch
zona <- "C"
switch(zona,A=3,B=6,C=,D=,E=30)
zona <- "B"
pasajeros <- 8
precio <- switch(zona,A=10,B=13,C=16,D=23,E=30)*pasajeros
precio
zona <- "G"
pasajeros <- 8
precio <- switch(zona,A=10,B=13,C=16,D=23,E=30)*pasajeros
precio
zona <- "E"
pasajeros <- 8
precio <- switch(zona,A=10,B=13,C=16,D=23,E=30)*pasajeros
precio
switch(3,1,2,3,4,5)
switch(3,1=5,2=2,3=19,4=2,5=4)
switch(3.5,1,2,3,4,5)
n <- 15
ifelse(n%%2==0,n<-n/2,n<-3*n+1)
n <- 15
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
n <- 8
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
ifelse(n%%2==0, n<-n/2, n<-3*n+1)
mean(c("A","E","I","O","U"))
datoDesconocido <- "R"
if(is.numeric(datoDesconocido)){
sqrt(datoDesconocido)
}else{
"El dato ingresado no es numerico."
}
datoDesconocido <- TRUE
if(is.numeric(datoDesconocido)){
sqrt(datoDesconocido)
}else{
"El dato ingresado no es numerico."
}
datoDesconocido <- 3.2
if(is.numeric(datoDesconocido)){
sqrt(datoDesconocido)
}else{
"El dato ingresado no es numerico."
}
datoDesconocido <- 9
if(is.numeric(datoDesconocido)){
sqrt(datoDesconocido)
}else{
"El dato ingresado no es numerico."
}
library(maps)       # Provides functions that let us plot the maps
install.packages("maps")
install.packages("mapdata")
map('worldHires')
library(maps)       # Provides functions that let us plot the maps
library(mapdata)    # Contains the hi-resolution points that mark out the countries.
map('worldHires')
map('world2Hires')
map('worldHires','ch')
save.image("C:/Users/Elaia/Desktop/xd.RData")
NA + 5
NULL + 5
remotes::install_github("RodrigoZepeda/covidmx@duckdb")
library(covidmx)
datos_covid <- descarga_datos_abiertos()
datos_covid |> casos() |> plot_covid()
df <- datos_covid |> casos()
datos_covid |> dplyr:
datos_covid |> casos()
datos_covid |> casos()
datos_covid$disconnect()
install.packages("datasauRus")
library("ggplot2")
install.packages("ggplot2")
library("ggplot2")
library("datasauRus")
ggplot(datasaurus_dozen, aes(x = x, y = y, colour = dataset))+
geom_point() +
theme_void() +
theme(legend.position = "none")+
facet_wrap(~dataset, ncol = 3)
datasaurus_dozen
datos <- datasaurus_dozen
View(datos)
getwd()
write.csv(datos,"Datasaurus.csv", row.names = FALSE)
# Initialize libraries, workspace, and functions
packages <- c("ggplot2",              # Create visualizations
"dplyr",                # Manipulate dataframes
"tibble",               # Auxiliary library for dplyr
"plyr",                 # Combine dataframes
"readr",                # read_csv is way faster than read.csv
"fpc",                  #
"cluster",              #
"ttutils")              # Merge is used to merge lists
install.packages(setdiff(packages, rownames(installed.packages())))
lapply(packages, library, character.only = TRUE)
rm(packages)
setwd("C:/Users/Elaia/Documents/Academia/Facultad/2022 (02) - Agosto-Diciembre/Data Mining/Clustering")
source("Toolkit.R")                   # Call custom functions
# File reading
tasks <- c(3,10,19)
kClust <- c(3,12,5)
data <- readData(tasks)
data <- normalizeData(data)
i=1
datosN.euc <- dist(data[[i]]$processedData, method = "euclidean")
CJ.complete <- hclust(datosN.euc, method="complete")
CJ.single   <- hclust(datosN.euc, method = "single")
CJ.average  <- hclust(datosN.euc, method = "average")
tags.complete <-as.numeric(cutree(CJ.complete, k=kClust[i]))
tags.single   <-as.numeric(cutree(CJ.single, k=kClust[i]))
tags.average  <-as.numeric(cutree(CJ.average, k=kClust[i]))
plot(CJ.complete, cex=.5)
plot(CJ.single, cex=.5)
plot(CJ.average, cex=.5)
plot(datosN,col=tags)
plot(datos[[i]]$processedData,col=tags)
plot(data[[i]]$processedData,col=tags)
plot(data[[i]]$processedData,col=data[[i]]$realTags)
plot(data[[i]]$processedData,col=tags.complete)
plot(data[[i]]$processedData,col=tags.single)
plot(data[[i]]$processedData,col=tags.average)
plot(data[[i]]$processedData,col=tags.single)
plot(data[[i]]$processedData,col=data[[i]]$realTags)
plot(data[[i]]$processedData,col=tags.complete+1)
plot(data[[i]]$processedData,col=tags.single+1)
plot(data[[i]]$processedData,col=tags.average+1)
plot(data[[i]]$processedData,col=data[[i]]$realTags)
plot(data[[i]]$processedData,col=tags.single+1)
plot(data[[i]]$processedData,col=data[[i]]$realTags)
# Initialize libraries, workspace, and functions
packages <- c("ggplot2",              # Create visualizations
"dplyr",                # Manipulate dataframes
"tibble",               # Auxiliary library for dplyr
"plyr",                 # Combine dataframes
"readr",                # read_csv is way faster than read.csv
"fpc",                  #
"cluster",              #
"ttutils")              # Merge is used to merge lists
install.packages(setdiff(packages, rownames(installed.packages())))
lapply(packages, library, character.only = TRUE)
rm(packages)
setwd("C:/Users/Elaia/Documents/Academia/Facultad/2022 (02) - Agosto-Diciembre/Data Mining/Clustering")
source("Toolkit.R")                   # Call custom functions
# EDA for all data. Save png files in export/
exportEDA()
# File reading
tasks <- c(3,10,19)
kClust <- c(3,12,5)
data <- readData(tasks)
data <- normalizeData(data)
# Hierarchical Clustering Modeling
data <- hClustering(data,kClust)
getConfusionMatrix <- function(observations,predictions){
# Gets True Positives, True Negatives, False Positives, and False Negatives
# Initialize variables
numData <- length(observations)
TP <- 0
TN <- 0
FP <- 0
FN <- 0
# Get the entries of the confusion matrix
for(i in 1:(numData-1)){
for(j in (i+1):numData){
# True Positives
if(observations[i]==observations[j] & predictions[i]==predictions[j]){
TP<-TP+1
}
# True Negatives
if(observations[i]!=observations[j] & predictions[i]!=predictions[j]){
TN<-TN+1
}
# False Negatives
if(observations[i]==observations[j] & predictions[i]!=predictions[j]){
FN<-FN+1
}
# False Positives
if(observations[i]!=observations[j] & predictions[i]==predictions[j]){
FP<-FP+1
}
}
}
# Store values in confusion matrix and put names in rows and columns
confusionMatrix           <- matrix(c(TP,FP,FN,TN),ncol=2, nrow=2)
colnames(confusionMatrix) <- c("PP","PN")
rownames(confusionMatrix) <- c("P", "N")
# Return confusionMatrix as output
return(confusionMatrix)
}
source("Toolkit.R")                   # Call custom functions
# Hierarchical Clustering Modeling
data <- hClustering(data,kClust)
data$basic3$hclust$complete$confusionMatrix
data$basic3$hclust$single$confusionMatrix
data$basic3$hclust$average$confusionMatrix
data$boxes3$hclust$complete$confusionMatrix
data$boxes3$hclust$single$confusionMatrix
data$boxes3$hclust$average$confusionMatrix
data$network$hclust$complete$confusionMatrix
data$network$hclust$single$confusionMatrix
data$network$hclust$average$confusionMatrix
?kmeans
tags.k<-kmeans(data$basic3$processedData,centers=3,iter.max=10,nstart=1)$cluster
tags.k
getConfusionMatrix(data$basic3$realTags,tags.k)
length(data$basic3$hclust)
paste("kmeans",1,sep="")
paste("kmeans.",1,sep="")
iterations=c(5,10,50,100)
namesResults <- paste("kmeans.",iterations,sep="")
# Initialize variables
numTasks           <- length(data)
numIterations      <- length(iterations)
numPreviousMethods <- length(data[[1]]$results)
numMethod          <- numPreviousMethods+numIterations
numMethod          <- numPreviousMethods+iterations
numMethod          <- numPreviousMethods+1:numIterations
numPreviousMethods <- 3
numMethod          <- numPreviousMethods+1:numIterations
numPreviousMethods <- 0
numMethod          <- numPreviousMethods+1:numIterations
names(data$basic3)
names(data$basic3[2:3])
numMethod
data$basic3$hclust['complete']
data$basic3$hclust['kmeans.10']$tags <- 1:10
data$basic3$hclust[['kmeans.10']]$tags <- 1:10
2 -> a
get.hclustering <- function(data,kClust,methods=("complete","single","average")){
# Initialize libraries, workspace, and functions
packages <- c("ggplot2",              # Create visualizations
"dplyr",                # Manipulate dataframes
"tibble",               # Auxiliary library for dplyr
"plyr",                 # Combine dataframes
"readr",                # read_csv is way faster than read.csv
"fpc",                  #
"cluster",              #
"ttutils")              # Merge is used to merge lists
install.packages(setdiff(packages, rownames(installed.packages())))
lapply(packages, library, character.only = TRUE)
rm(packages)
setwd("C:/Users/Elaia/Documents/Academia/Facultad/2022 (02) - Agosto-Diciembre/Data Mining/Clustering")
source("Toolkit.R")                   # Call custom functions
# EDA for all data. Save png files in export/
exportEDA()
# File reading
tasks <- c(3,10,19)
kClust <- c(3,12,5)
data <- readData(tasks)
data <- normalizeData(data)
# K-means and Hierarchical Clustering Modeling
data <- get.kmeans(data,kClust)
get.kmeans <- function(data,kClust,iterations=c(5,10,50,100)){
# Gets kmeans
# Initialize variables
numTasks           <- length(data)
numIterations      <- length(iterations)
namesResults       <- paste("kmeans.",iterations,sep="")
# Gets clusters for all data sets with different hyperparameters
for(i in 1:numTasks){
for(j in 1:numIterations){
# Get predicted tags using kmeans
tags.kmeans <- kmeans(data[[i]]$processedData,
centers=kClust[i],
iter.max=iterations[j],
nstart=1)$cluster
# Get confusion matrix for this instance
matrix.kmeans <- get.confusionMatrix(data[[i]]$realTags,tags.kmeans)
# Save tags and confusion matrix in results list
tags.kmeans   -> data[[i]]$results[[namesResults[j]]]$tags
matrix.kmeans -> data[[i]]$results[[namesResults[j]]]$confusionMatrix
}
}
# Return results
return(data)
}
# K-means and Hierarchical Clustering Modeling
data <- get.kmeans(data,kClust)
# Initialize libraries, workspace, and functions
packages <- c("ggplot2",              # Create visualizations
"dplyr",                # Manipulate dataframes
"tibble",               # Auxiliary library for dplyr
"plyr",                 # Combine dataframes
"readr",                # read_csv is way faster than read.csv
"fpc",                  #
"cluster")              #
install.packages(setdiff(packages, rownames(installed.packages())))
lapply(packages, library, character.only = TRUE)
rm(packages)
setwd("C:/Users/Elaia/Documents/Academia/Facultad/2022 (02) - Agosto-Diciembre/Data Mining/Clustering")
source("Toolkit.R")                   # Call custom functions
# File reading
tasks <- c(3,10,19)
kClust <- c(3,12,5)
data <- readData(tasks)
data <- normalizeData(data)
# K-means and Hierarchical Clustering Modeling
data <- get.kmeans(data,kClust)
View(data)
ggplot(data=data$basic3$processedData)
ggplot(data, aes=(x,y)) + geom_point)=
ggplot(data, aes=(x,y)) + geom_point()
ggplot(data, aes(x,y)) + geom_point()
ggplot(data$basic3$processedData, aes(x,y)) + geom_point()
+ theme_light()
ggplot(data$basic3$processedData, aes(x,y)) + geom_point() + theme_light()
ggplot(data$basic3$processedData, aes(x,y)) + geom_point() + theme_linedraw()
ggplot(data$basic3$processedData, aes(x,y)) + geom_point() + theme_minimal()
ggplot(data$basic3$processedData, aes(x,y)) + geom_point() + theme_light()
ggplot(data$basic3$processedData, aes(x,y))
+ geom_point() + theme_light() +
xlab("Weight (x1000 lb)") + ylab("Miles per Gallon") +
theme(text=element_text(size=16,
family="Comic Sans MS"))
# Single method of hierarchical clustering
HC.single     <- hclust(dataEuclidean, method = "single")
ggplot(data$basic3$processedData, aes(x,y))
ggplot(data$basic3$processedData, aes(x,y))
+ geom_point() + theme_light() +
xlab("Weight (x1000 lb)") + ylab("Miles per Gallon") +
theme(text=element_text(size=16,
family="Comic Sans MS"))
ggplot(data$basic3$processedData, aes(x,y)) +
geom_point() + theme_light() +
xlab("Weight (x1000 lb)") + ylab("Miles per Gallon") +
theme(text=element_text(size=16,
family="Comic Sans MS"))
#       family="CM Roman"))
#       family="TT Times New Roman"))
#       family="Sans"))
#family="Serif"))
ggplot(data$basic3$processedData, aes(x,y)) + geom_point(aes(fill = color)) +
theme_light() + xlab("Variable x") + ylab("Variable y") +
##################
##
# Single method of hierarchical clustering
HC.single     <- hclust(dataEuclidean, method = "single")
ggplot(data$basic3$processedData, aes(x,y)) + geom_point(aes(fill = color)) +
theme_light() + xlab("Variable x") + ylab("Variable y")
bind_cols(data$basic3$processedData,data$basic3$realTags
)
bind_cols(data$basic3$processedData,color=data$basic3$realTags)
ggplot(bind_cols(data$basic3$processedData,color=data$basic3$realTags), aes(x,y)) +
geom_point(aes(fill = color)) +
theme_light() + xlab("Variable x") + ylab("Variable y")
ggplot(bind_cols(data$basic3$processedData,color=as.factor(data$basic3$realTags)), aes(x,y)) +
geom_point(aes(fill = color)) +
theme_light() + xlab("Variable x") + ylab("Variable y")
ggplot(bind_cols(data$basic3$processedData,color=as.factor(data$basic3$realTags)), aes(x,y)) +
theme_light() + xlab("Variable x") + ylab("Variable y")
ggplot(bind_cols(data$basic3$processedData,color=as.factor(data$basic3$realTags)), aes(x,y)) +
ggplot(bind_cols(data$basic3$processedData,color=as.factor(data$basic3$realTags)), aes(x,y)) +
geom_point(aes(fill=color, shape=color)
.
ggplot(bind_cols(data$basic3$processedData,color=as.factor(data$basic3$realTags)), aes(x,y)) +
geom_point(aes(fill=color, shape=color))
tibble.df <- bind_cols(data$basic3$processedData,color=as.character(data$basic3$realTags)
)
tibble.df
ggplot(tibble.df,aes(x=x,y=y)) + geom_point(aes(fill=color, shape=color))
?aes
ggplot(tibble.df,aes(x=x,y=y)) + geom_point(aes(color=color, shape=color))
ggplot(tibble.df,aes(x,y)) + geom_point(aes(color=color, shape=color))
tibble.df <- bind_cols(data$boxes3$processedData,color=as.character(data$basic3$realTags))
tibble.df <- bind_cols(data$boxes3$processedData,color=as.character(data$boxes3$realTags))
ggplot(tibble.df,aes(x,y)) + geom_point(aes(color=color, shape=color))
ggplot(tibble.df,aes(x,y)) + geom_point(aes(color=color))
ggplot(tibble.df,aes(x,y)) + geom_point(aes(color=color,size=1))
ggplot(tibble.df,aes(x,y)) + geom_point(aes(color=color,size=0.1))
ggplot(tibble.df,aes(x,y,size=1)) + geom_point(aes(color=color))
tibble.df <- bind_cols(data$boxes3$processedData,color=paste("Grupo ",data$boxes3$realTags))
ggplot(tibble.df,aes(x,y)) + geom_point(aes(color=color))
